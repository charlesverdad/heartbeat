#!/usr/bin/env python3
"""
Kubernetes deployment workflow script.

This script manages the rendering of Helm templates to plain YAML and
deployment using Kustomize overlays.

Usage:
    ./bin/k8s build <component>     - Build manifests for a component
    ./bin/k8s build-all             - Build all components
    ./bin/k8s deploy <env>          - Deploy to environment (dev/prod)
    ./bin/k8s list                  - List available components
"""

import argparse
import os
import sys
import subprocess
import yaml
import shutil
from pathlib import Path
from typing import List, Dict, Any


class K8sWorkflow:
    def __init__(self):
        self.root_dir = Path(__file__).parent.parent
        self.src_dir = self.root_dir / "k8s" / "manifests" / "src"
        self.base_dir = self.root_dir / "k8s" / "manifests" / "base"
        self.overlays_dir = self.root_dir / "k8s" / "manifests" / "overlays"
        self.rendered_dir = self.root_dir / "k8s" / "manifests" / "rendered"
        
    def run_command(self, cmd: List[str], cwd: Path = None) -> subprocess.CompletedProcess:
        """Run a shell command and return the result."""
        try:
            result = subprocess.run(
                cmd, 
                cwd=cwd or self.root_dir, 
                capture_output=True, 
                text=True, 
                check=True
            )
            return result
        except subprocess.CalledProcessError as e:
            print(f"Error running command: {' '.join(cmd)}")
            print(f"Exit code: {e.returncode}")
            print(f"Stdout: {e.stdout}")
            print(f"Stderr: {e.stderr}")
            sys.exit(1)

    def list_components(self) -> List[str]:
        """List all available components in the src directory."""
        if not self.src_dir.exists():
            return []
        
        components = []
        for item in self.src_dir.iterdir():
            if item.is_dir():
                components.append(item.name)
        return sorted(components)

    def is_helm_chart(self, component_path: Path) -> bool:
        """Check if a component is a Helm chart."""
        return (component_path / "Chart.yaml").exists()

    def render_helm_chart(self, component: str) -> None:
        """Render a Helm chart to plain YAML."""
        src_path = self.src_dir / component
        base_path = self.base_dir / component
        
        if not self.is_helm_chart(src_path):
            print(f"Component {component} is not a Helm chart, skipping Helm rendering")
            return
            
        print(f"Rendering Helm chart: {component}")
        
        # Create base directory
        base_path.mkdir(parents=True, exist_ok=True)
        
        # Find values files
        values_files = []
        values_yaml = src_path / "values.yaml"
        if values_yaml.exists():
            values_files.extend(["-f", str(values_yaml)])
        
        # Look for additional values files
        for values_file in src_path.glob("values-*.yaml"):
            values_files.extend(["-f", str(values_file)])
        
        # Clear existing rendered files
        if base_path.exists():
            shutil.rmtree(base_path)
        
        # Create a temporary output directory
        temp_output_dir = base_path.parent / f"{component}-temp"
        if temp_output_dir.exists():
            shutil.rmtree(temp_output_dir)
        
        # Render using helm template
        cmd = [
            "helm", "template", component,
            str(src_path),
            "--output-dir", str(temp_output_dir),
            "--namespace", "default"
        ] + values_files
        
        self.run_command(cmd)
        
        # Helm template creates a subdirectory with the chart name
        helm_output_dir = temp_output_dir / component
        if helm_output_dir.exists():
            # Move the rendered templates to the expected base directory
            base_path.mkdir(parents=True, exist_ok=True)
            
            # Move all files from the helm output directory
            for item in helm_output_dir.rglob("*"):
                if item.is_file():
                    # Calculate relative path and create target
                    rel_path = item.relative_to(helm_output_dir)
                    target_path = base_path / rel_path
                    target_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.move(str(item), str(target_path))
            
            # Clean up temp directory
            shutil.rmtree(temp_output_dir)
        else:
            print(f"Warning: Expected Helm output directory {helm_output_dir} not found")
            # Clean up temp directory anyway
            if temp_output_dir.exists():
                shutil.rmtree(temp_output_dir)
        
        print(f"✓ Rendered {component} to {base_path}")

    def copy_vanilla_yaml(self, component: str) -> None:
        """Copy vanilla YAML files to base directory."""
        src_path = self.src_dir / component
        base_path = self.base_dir / component
        
        if self.is_helm_chart(src_path):
            return  # Skip if it's a Helm chart
            
        print(f"Copying vanilla YAML: {component}")
        
        # Create base directory
        base_path.mkdir(parents=True, exist_ok=True)
        
        # Copy all YAML files
        yaml_files = list(src_path.glob("*.yaml")) + list(src_path.glob("*.yml"))
        
        if not yaml_files:
            print(f"No YAML files found in {src_path}")
            return
        
        for yaml_file in yaml_files:
            shutil.copy2(yaml_file, base_path)
        
        print(f"✓ Copied {len(yaml_files)} YAML files to {base_path}")

    def create_kustomization(self, component: str) -> None:
        """Create a kustomization.yaml file for the component."""
        base_path = self.base_dir / component
        
        if not base_path.exists():
            print(f"Base directory {base_path} does not exist, skipping kustomization")
            return
        
        # Find all YAML files in the base directory (including subdirectories)
        # but exclude kustomization.yaml itself
        yaml_files = []
        for pattern in ["*.yaml", "*.yml"]:
            for yaml_file in base_path.rglob(pattern):
                # Skip kustomization.yaml files
                if yaml_file.name == "kustomization.yaml":
                    continue
                # Get relative path from base_path
                rel_path = yaml_file.relative_to(base_path)
                yaml_files.append(str(rel_path))
        
        if not yaml_files:
            print(f"No YAML files found in {base_path}, skipping kustomization")
            return
        
        kustomization = {
            "apiVersion": "kustomize.config.k8s.io/v1beta1",
            "kind": "Kustomization",
            "resources": sorted(yaml_files)
        }
        
        kustomization_file = base_path / "kustomization.yaml"
        with open(kustomization_file, 'w') as f:
            yaml.dump(kustomization, f, default_flow_style=False, sort_keys=False)
        
        print(f"✓ Created kustomization.yaml for {component}")

    def split_yaml_documents(self, yaml_content: str) -> List[Dict[str, Any]]:
        """Split a multi-document YAML string into individual documents."""
        documents = []
        for doc in yaml.safe_load_all(yaml_content):
            if doc:  # Skip empty documents
                documents.append(doc)
        return documents

    def generate_filename(self, doc: Dict[str, Any]) -> str:
        """Generate a filename for a Kubernetes resource."""
        kind = doc.get('kind', 'unknown').lower()
        name = doc.get('metadata', {}).get('name', 'unnamed')
        
        # Create a safe filename without namespace (since we organize by directory)
        filename = f"{kind}-{name}"
        
        # Replace invalid characters
        filename = filename.replace('/', '-').replace(':', '-')
        return f"{filename}.yaml"

    def render_environment(self, env: str) -> None:
        """Render final manifests for a specific environment."""
        overlay_path = self.overlays_dir / env
        
        if not overlay_path.exists():
            print(f"Environment overlay {env} not found at {overlay_path}")
            return
        
        if not (overlay_path / "kustomization.yaml").exists():
            print(f"No kustomization.yaml found in {overlay_path}")
            return
        
        print(f"Rendering final manifests for environment: {env}")
        
        # Create environment directory
        env_dir = self.rendered_dir / env
        env_dir.mkdir(parents=True, exist_ok=True)
        
        # Run kustomize build
        cmd = ["kustomize", "build", str(overlay_path)]
        result = self.run_command(cmd)
        
        # Split the output into individual documents
        documents = self.split_yaml_documents(result.stdout)
        
        if not documents:
            print(f"No documents rendered for environment {env}")
            return
        
        # Group documents by namespace
        namespace_docs = {}
        for doc in documents:
            namespace = doc.get('metadata', {}).get('namespace', 'default')
            if namespace not in namespace_docs:
                namespace_docs[namespace] = []
            namespace_docs[namespace].append(doc)
        
        total_files = 0
        # Write each document to a separate file organized by environment/namespace
        for namespace, docs in namespace_docs.items():
            namespace_dir = env_dir / namespace
            namespace_dir.mkdir(parents=True, exist_ok=True)
            
            # Clear existing rendered files in this namespace
            for file in namespace_dir.glob("*.yaml"):
                file.unlink()
            
            for doc in docs:
                filename = self.generate_filename(doc)
                file_path = namespace_dir / filename
                
                with open(file_path, 'w') as f:
                    yaml.dump(doc, f, default_flow_style=False, sort_keys=False)
                total_files += 1
        
        namespaces = list(namespace_docs.keys())
        print(f"✓ Rendered {total_files} manifests across {len(namespaces)} namespace(s): {', '.join(namespaces)}")

    def render_all_environments(self) -> None:
        """Render final manifests for all environments."""
        environments = self.list_environments()
        
        if not environments:
            print("No environments found")
            return
        
        print(f"\nRendering final manifests for {len(environments)} environments...")
        
        for env in environments:
            self.render_environment(env)

    def build_component(self, component: str) -> None:
        """Build a single component."""
        src_path = self.src_dir / component
        
        if not src_path.exists():
            print(f"Component {component} not found in {self.src_dir}")
            sys.exit(1)
        
        print(f"\n=== Building component: {component} ===")
        
        if self.is_helm_chart(src_path):
            self.render_helm_chart(component)
        else:
            self.copy_vanilla_yaml(component)
        
        self.create_kustomization(component)
        
        # Render final manifests for all environments
        self.render_all_environments()

    def build_all(self) -> None:
        """Build all components."""
        components = self.list_components()
        
        if not components:
            print("No components found in src directory")
            return
        
        print(f"Building {len(components)} components...")
        
        for component in components:
            src_path = self.src_dir / component
            
            print(f"\n=== Building component: {component} ===")
            
            if self.is_helm_chart(src_path):
                self.render_helm_chart(component)
            else:
                self.copy_vanilla_yaml(component)
            
            self.create_kustomization(component)
        
        # Render final manifests for all environments once at the end
        self.render_all_environments()
        
        print(f"\n✓ Successfully built {len(components)} components")

    def deploy(self, env: str) -> None:
        """Deploy to a specific environment using Kustomize overlay."""
        overlay_path = self.overlays_dir / env
        
        if not overlay_path.exists():
            print(f"Environment overlay {env} not found at {overlay_path}")
            print(f"Available environments: {self.list_environments()}")
            sys.exit(1)
        
        if not (overlay_path / "kustomization.yaml").exists():
            print(f"No kustomization.yaml found in {overlay_path}")
            sys.exit(1)
        
        print(f"Deploying to environment: {env}")
        
        cmd = ["kubectl", "apply", "-k", str(overlay_path)]
        result = self.run_command(cmd)
        
        print("✓ Deployment completed")
        if result.stdout:
            print(result.stdout)

    def list_environments(self) -> List[str]:
        """List available environments."""
        if not self.overlays_dir.exists():
            return []
        
        envs = []
        for item in self.overlays_dir.iterdir():
            if item.is_dir() and (item / "kustomization.yaml").exists():
                envs.append(item.name)
        return sorted(envs)


def main():
    parser = argparse.ArgumentParser(description="Kubernetes deployment workflow")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Build command
    build_parser = subparsers.add_parser("build", help="Build component manifests")
    build_parser.add_argument("component", help="Component name to build")
    
    # Build-all command
    subparsers.add_parser("build-all", help="Build all component manifests")
    
    # Deploy command
    deploy_parser = subparsers.add_parser("deploy", help="Deploy to environment")
    deploy_parser.add_argument("env", help="Environment name (dev, prod, etc.)")
    
    # List command
    subparsers.add_parser("list", help="List available components")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    workflow = K8sWorkflow()
    
    if args.command == "build":
        workflow.build_component(args.component)
    elif args.command == "build-all":
        workflow.build_all()
    elif args.command == "deploy":
        workflow.deploy(args.env)
    elif args.command == "list":
        components = workflow.list_components()
        envs = workflow.list_environments()
        
        print("Available components:")
        for component in components:
            print(f"  - {component}")
        
        print("\nAvailable environments:")
        for env in envs:
            print(f"  - {env}")


if __name__ == "__main__":
    main()
